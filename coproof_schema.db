-- =============================================================================
-- COPROOF BACKEND - POSTGRESQL SCHEMA (GIT-INDEX ARCHITECTURE)
-- Version: 2.0 (Stateless/Git-Based)
-- Description: Defines the Relational Index for the CoProof Graph.
--              Content is stored in Git; this DB stores metadata, relationships,
--              and sync status.
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 1. EXTENSIONS & SCHEMA SETUP
-- -----------------------------------------------------------------------------

-- Create a dedicated schema to isolate application data
CREATE SCHEMA IF NOT EXISTS coproof_schema;

-- Enable UUID generation (v4)
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Set search path to prioritize our schema
SET search_path TO coproof_schema;

-- -----------------------------------------------------------------------------
-- 2. ENUMS (TYPE SAFETY)
-- -----------------------------------------------------------------------------

CREATE TYPE project_visibility_enum AS ENUM ('public', 'private');

-- Node status in the verification pipeline
CREATE TYPE node_status_enum AS ENUM ('pending', 'in_review', 'verified', 'error');

-- Semantic type of the node (Metadata for the Graph)
CREATE TYPE node_type_enum AS ENUM ('global_goal', 'theorem', 'lemma', 'corollary', 'definition', 'numerical_eval');

-- Status of async jobs (Agent, Git Sync, etc.)
CREATE TYPE job_status_enum AS ENUM ('queued', 'processing', 'completed', 'failed');

-- Types of background jobs
CREATE TYPE job_type_enum AS ENUM ('git_push', 'git_clone', 'rag_sync', 'agent_exploration', 'cluster_experiment');

-- -----------------------------------------------------------------------------
-- 3. TABLES (DDL)
-- -----------------------------------------------------------------------------

-- [USERS]
-- Identity management. Passwords should be hashed (Argon2/Bcrypt) by the App.
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    full_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    is_verified BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- [PROJECTS]
-- Metadata container. The 'remote_repo_url' is the Single Source of Truth.
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    description TEXT,
    visibility project_visibility_enum NOT NULL DEFAULT 'private',
    leader_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
    
    -- GIT CONFIGURATION
    remote_repo_url TEXT,     -- URL to GitHub/GitLab
    default_branch TEXT NOT NULL DEFAULT 'main',
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- [COLLABORATORS]
-- Junction table for Many-to-Many relationship (Users <-> Projects)
CREATE TABLE collaborators (
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    joined_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (project_id, user_id)
);

-- [GRAPH_INDEX] (Formerly nodos_grafo)
-- The Index pointing to the Git content. 
-- It does NOT store the proof text. It stores where to find it.
CREATE TABLE graph_index (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    
    -- METADATA
    title TEXT NOT NULL,
    node_type node_type_enum NOT NULL,
    status node_status_enum NOT NULL DEFAULT 'pending',
    
    -- GIT POINTERS (The Link to Truth)
    file_path TEXT NOT NULL,    -- Relative path in repo (e.g., 'src/thm_1.lean')
    start_line INTEGER,         -- Line number start in file
    end_line INTEGER,           -- Line number end in file
    commit_hash TEXT,           -- The Git Commit Hash this index represents
    
    -- AGENT/RAG METADATA
    rag_synced_at TIMESTAMPTZ,  -- When was this last sent to the Agent's Vector DB?
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Constraint: Only one node per file? usually no, multiple theorems per file.
    -- But (project_id, title) should likely be unique to avoid ambiguity.
    UNIQUE (project_id, title)
);

-- [DEPENDENCIES] (Edges)
-- Adjacency list for the graph structure.
CREATE TABLE dependencies (
    source_id UUID NOT NULL REFERENCES graph_index(id) ON DELETE CASCADE,
    target_id UUID NOT NULL REFERENCES graph_index(id) ON DELETE CASCADE,
    
    -- Prevent self-loops and duplicate edges
    CHECK (source_id != target_id),
    PRIMARY KEY (source_id, target_id)
);

-- [CHANGE_REQUESTS] (Branches/PRs)
-- Maps internal "Change Requests" to Git Branches.
CREATE TABLE change_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    requester_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    title TEXT NOT NULL,
    description TEXT,
    
    -- GIT MAPPING
    source_branch TEXT NOT NULL, -- The feature branch (e.g., 'feat/user-x-lemma')
    target_branch TEXT NOT NULL DEFAULT 'main',
    pr_number INTEGER,           -- If linked to a GitHub PR
    
    status TEXT NOT NULL CHECK (status IN ('open', 'merged', 'closed')),
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- [ASYNC_JOBS]
-- Tracks Celery tasks for UI feedback.
CREATE TABLE async_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    
    celery_task_id TEXT NOT NULL, -- The ID from Celery
    job_type job_type_enum NOT NULL,
    status job_status_enum NOT NULL DEFAULT 'queued',
    
    result_metadata JSONB,        -- Store small results (e.g., {"next_step": "..."})
    error_log TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- -----------------------------------------------------------------------------
-- 4. INDEXES (PERFORMANCE)
-- -----------------------------------------------------------------------------

-- Users
CREATE INDEX idx_users_email ON users(email);

-- Projects
CREATE INDEX idx_projects_leader ON projects(leader_id);
CREATE INDEX idx_projects_public ON projects(id) WHERE visibility = 'public';

-- Graph Index
CREATE INDEX idx_graph_project ON graph_index(project_id);
CREATE INDEX idx_graph_file_path ON graph_index(file_path); -- Fast file lookups
CREATE INDEX idx_graph_rag_sync ON graph_index(rag_synced_at) WHERE rag_synced_at IS NULL; -- Find unsynced nodes

-- Dependencies
CREATE INDEX idx_deps_target ON dependencies(target_id); -- Find "Used By" (Reverse Lookup)

-- Jobs
CREATE INDEX idx_jobs_user_status ON async_jobs(user_id, status);

-- -----------------------------------------------------------------------------
-- 5. AUTOMATIC TIMESTAMP TRIGGER
-- -----------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER trg_users_updated BEFORE UPDATE ON users FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER trg_projects_updated BEFORE UPDATE ON projects FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER trg_graph_index_updated BEFORE UPDATE ON graph_index FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER trg_change_req_updated BEFORE UPDATE ON change_requests FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER trg_async_jobs_updated BEFORE UPDATE ON async_jobs FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

-- -----------------------------------------------------------------------------
-- 6. SECURITY ROLES (LEAST PRIVILEGE)
-- -----------------------------------------------------------------------------

-- Role for the Flask Application
-- DO NOT grant SUPERUSER. Only DML permissions on this schema.
CREATE ROLE coproof_app_user WITH LOGIN PASSWORD 'CHANGE_THIS_IN_PRODUCTION';

GRANT USAGE ON SCHEMA coproof_schema TO coproof_app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA coproof_schema TO coproof_app_user;
-- Grant usage on any sequences if used (though we use UUIDs mostly)
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA coproof_schema TO coproof_app_user;

-- Role for Migrations/Admin
CREATE ROLE coproof_admin WITH LOGIN PASSWORD 'CHANGE_THIS_ADMIN_PASS';
GRANT ALL PRIVILEGES ON SCHEMA coproof_schema TO coproof_admin;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA coproof_schema TO coproof_admin;

-- -----------------------------------------------------------------------------
-- 7. ROW LEVEL SECURITY (RLS) - OPTIONAL / ADVANCED
-- -----------------------------------------------------------------------------
-- RLS enforces that users can only query projects they have access to.
-- NOTE: For this to work, the Flask App must set a config variable per request:
-- SET LOCAL app.current_user_id = 'uuid';

/*
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

CREATE POLICY project_access_policy ON projects
FOR SELECT
USING (
    visibility = 'public'
    OR leader_id = current_setting('app.current_user_id', true)::uuid
    OR EXISTS (
        SELECT 1 FROM collaborators 
        WHERE project_id = projects.id 
        AND user_id = current_setting('app.current_user_id', true)::uuid
    )
);

-- Similar policies would be needed for graph_index, change_requests, etc.
-- For the initial implementation, we often handle this in the Application Service Layer 
-- to reduce complexity, but RLS is the gold standard for security.
*/